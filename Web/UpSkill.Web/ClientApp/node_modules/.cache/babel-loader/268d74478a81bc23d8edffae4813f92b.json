{"ast":null,"code":"'use strict';\n\nconst stdin = process.stdin;\nconst stderr = process.stderr;\nlet read = {\n  hide: (ask, options = {}) => read.raw(ask, false, options),\n  mask: (ask, options = {}) => read.raw(ask, true, options),\n  raw: (ask, maskAfter, options = {}) => {\n    // masking isn't available without setRawMode\n    if (!stdin.setRawMode || process.env.TERM === 'dumb') return read.notty(ask);\n    return new Promise(function (resolve, reject) {\n      const ansi = require('ansi-escapes');\n\n      let input = '';\n      stderr.write(ansi.eraseLine);\n      stderr.write(ansi.cursorLeft);\n      stderr.write(ask);\n      stdin.resume();\n      stdin.setRawMode(true);\n\n      function stop() {\n        if (maskAfter) {\n          stderr.write(ansi.cursorHide + ansi.cursorLeft + ask + input.replace(/./g, '*') + '\\n' + ansi.cursorShow);\n        } else {\n          stderr.write('\\n');\n        }\n\n        stdin.removeListener('data', fn);\n        stdin.setRawMode(false);\n        stdin.pause();\n      }\n\n      function enter() {\n        if (options.required && input.length === 0) return;\n        stop();\n        input = input.replace(/\\r$/, '');\n        input = input || options.default;\n        resolve(input);\n      }\n\n      function ctrlc() {\n        reject(new Error('SIGINT'));\n        stop();\n      }\n\n      function backspace() {\n        if (input.length === 0) return;\n        input = input.substr(0, input.length - 1);\n        stderr.write(ansi.cursorBackward(1));\n        stderr.write(ansi.eraseEndLine);\n      }\n\n      function newchar(c) {\n        input += c;\n        stderr.write(maskAfter ? c : '*'.repeat(c.length));\n      }\n\n      let fn = function (c) {\n        switch (c) {\n          case '\\u0004': // Ctrl-d\n\n          case '\\r':\n          case '\\n':\n            return enter();\n\n          case '\\u0003':\n            // Ctrl-c\n            return ctrlc();\n\n          default:\n            // backspace\n            if (c.charCodeAt(0) === 127) return backspace();else return newchar(c);\n        }\n      };\n\n      stdin.on('data', fn);\n    });\n  },\n  notty: ask => {\n    return new Promise((resolve, reject) => {\n      const spawn = require('cross-spawn');\n\n      stderr.write(ask);\n      let output = spawn.sync('sh', ['-c', 'read -s PASS && echo $PASS'], {\n        stdio: ['inherit', 'pipe', 'inherit'],\n        encoding: 'utf8'\n      });\n      stderr.write('\\n');\n      if (output.error) return reject(output.error);\n      resolve(output.stdout.trim());\n    });\n  }\n};\n/**\n * prompt -- Prompt for a password\n * @module password-prompt\n * @example\n * let prompt = require('password-prompt')\n * let password = prompt('password: ')\n * // password: ******\n * @param {string} [ask] - prompt output\n * @param {Object} [options]\n * @param {string} [options.method=mask] - mask or hide\n * @returns {Promise<string>} input from user\n */\n\nfunction prompt(ask, options = {}) {\n  options = Object.assign({\n    method: 'mask',\n    required: options.default === undefined,\n    default: ''\n  }, options);\n  stdin.setEncoding('utf8');\n  return read[options.method](ask, options).then(input => input || (options.required ? prompt(ask) : ''));\n}\n\nmodule.exports = prompt;","map":{"version":3,"sources":["H:/Programming Repositories/Titans/Web/UpSkill.Web/ClientApp/node_modules/password-prompt/index.js"],"names":["stdin","process","stderr","read","hide","ask","options","raw","mask","maskAfter","setRawMode","env","TERM","notty","Promise","resolve","reject","ansi","require","input","write","eraseLine","cursorLeft","resume","stop","cursorHide","replace","cursorShow","removeListener","fn","pause","enter","required","length","default","ctrlc","Error","backspace","substr","cursorBackward","eraseEndLine","newchar","c","repeat","charCodeAt","on","spawn","output","sync","stdio","encoding","error","stdout","trim","prompt","Object","assign","method","undefined","setEncoding","then","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst stdin = process.stdin\nconst stderr = process.stderr\n\nlet read = {\n  hide: (ask, options = {}) => read.raw(ask, false, options),\n  mask: (ask, options = {}) => read.raw(ask, true, options),\n  raw: (ask, maskAfter, options = {}) => {\n    // masking isn't available without setRawMode\n    if (!stdin.setRawMode || process.env.TERM === 'dumb') return read.notty(ask)\n    return new Promise(function (resolve, reject) {\n      const ansi = require('ansi-escapes')\n\n      let input = ''\n      stderr.write(ansi.eraseLine)\n      stderr.write(ansi.cursorLeft)\n      stderr.write(ask)\n      stdin.resume()\n      stdin.setRawMode(true)\n\n      function stop () {\n        if (maskAfter) {\n          stderr.write(ansi.cursorHide + ansi.cursorLeft + ask + input.replace(/./g, '*') + '\\n' + ansi.cursorShow)\n        } else {\n          stderr.write('\\n')\n        }\n        stdin.removeListener('data', fn)\n        stdin.setRawMode(false)\n        stdin.pause()\n      }\n\n      function enter () {\n        if (options.required && input.length === 0) return\n        stop()\n        input = input.replace(/\\r$/, '')\n        input = input || options.default\n        resolve(input)\n      }\n\n      function ctrlc () {\n        reject(new Error('SIGINT'))\n        stop()\n      }\n\n      function backspace () {\n        if (input.length === 0) return\n        input = input.substr(0, input.length - 1)\n        stderr.write(ansi.cursorBackward(1))\n        stderr.write(ansi.eraseEndLine)\n      }\n\n      function newchar (c) {\n        input += c\n        stderr.write(maskAfter ? c : '*'.repeat(c.length))\n      }\n\n      let fn = function (c) {\n        switch (c) {\n          case '\\u0004': // Ctrl-d\n          case '\\r':\n          case '\\n':\n            return enter()\n          case '\\u0003': // Ctrl-c\n            return ctrlc()\n          default:\n            // backspace\n            if (c.charCodeAt(0) === 127) return backspace()\n            else return newchar(c)\n        }\n      }\n      stdin.on('data', fn)\n    })\n  },\n  notty: ask => {\n    return new Promise((resolve, reject) => {\n      const spawn = require('cross-spawn')\n      stderr.write(ask)\n      let output = spawn.sync('sh', ['-c', 'read -s PASS && echo $PASS'], {\n        stdio: ['inherit', 'pipe', 'inherit'],\n        encoding: 'utf8'\n      })\n      stderr.write('\\n')\n      if (output.error) return reject(output.error)\n      resolve(output.stdout.trim())\n    })\n  }\n}\n\n/**\n * prompt -- Prompt for a password\n * @module password-prompt\n * @example\n * let prompt = require('password-prompt')\n * let password = prompt('password: ')\n * // password: ******\n * @param {string} [ask] - prompt output\n * @param {Object} [options]\n * @param {string} [options.method=mask] - mask or hide\n * @returns {Promise<string>} input from user\n */\nfunction prompt (ask, options = {}) {\n  options = Object.assign(\n    {\n      method: 'mask',\n      required: options.default === undefined,\n      default: ''\n    },\n    options\n  )\n  stdin.setEncoding('utf8')\n  return read[options.method](ask, options).then(input => input || (options.required ? prompt(ask) : ''))\n}\n\nmodule.exports = prompt\n"]},"metadata":{},"sourceType":"script"}