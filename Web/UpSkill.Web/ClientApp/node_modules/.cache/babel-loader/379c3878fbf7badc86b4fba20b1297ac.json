{"ast":null,"code":"// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\nimport { LogLevel } from \"./ILogger\";\nimport { Platform, getGlobalThis } from \"./Utils\";\nexport class FetchHttpClient extends HttpClient {\n  constructor(logger) {\n    super();\n    this._logger = logger;\n\n    if (typeof fetch === \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require; // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\n\n      this._jar = new (requireFunc(\"tough-cookie\").CookieJar)();\n      this._fetchType = requireFunc(\"node-fetch\"); // node-fetch doesn't have a nice API for getting and setting cookies\n      // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\n\n      this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\n    } else {\n      this._fetchType = fetch.bind(getGlobalThis());\n    }\n\n    if (typeof AbortController === \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require; // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\n\n      this._abortControllerType = requireFunc(\"abort-controller\");\n    } else {\n      this._abortControllerType = AbortController;\n    }\n  }\n  /** @inheritDoc */\n\n\n  async send(request) {\n    // Check that abort was not signaled before calling send\n    if (request.abortSignal && request.abortSignal.aborted) {\n      throw new AbortError();\n    }\n\n    if (!request.method) {\n      throw new Error(\"No method defined.\");\n    }\n\n    if (!request.url) {\n      throw new Error(\"No url defined.\");\n    }\n\n    const abortController = new this._abortControllerType();\n    let error; // Hook our abortSignal into the abort controller\n\n    if (request.abortSignal) {\n      request.abortSignal.onabort = () => {\n        abortController.abort();\n        error = new AbortError();\n      };\n    } // If a timeout has been passed in, setup a timeout to call abort\n    // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\n\n\n    let timeoutId = null;\n\n    if (request.timeout) {\n      const msTimeout = request.timeout;\n      timeoutId = setTimeout(() => {\n        abortController.abort();\n\n        this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\n\n        error = new TimeoutError();\n      }, msTimeout);\n    }\n\n    let response;\n\n    try {\n      response = await this._fetchType(request.url, {\n        body: request.content,\n        cache: \"no-cache\",\n        credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\n        headers: {\n          \"Content-Type\": \"text/plain;charset=UTF-8\",\n          \"X-Requested-With\": \"XMLHttpRequest\",\n          ...request.headers\n        },\n        method: request.method,\n        mode: \"cors\",\n        redirect: \"follow\",\n        signal: abortController.signal\n      });\n    } catch (e) {\n      if (error) {\n        throw error;\n      }\n\n      this._logger.log(LogLevel.Warning, `Error from HTTP request. ${e}.`);\n\n      throw e;\n    } finally {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n\n      if (request.abortSignal) {\n        request.abortSignal.onabort = null;\n      }\n    }\n\n    if (!response.ok) {\n      const errorMessage = await deserializeContent(response, \"text\");\n      throw new HttpError(errorMessage || response.statusText, response.status);\n    }\n\n    const content = deserializeContent(response, request.responseType);\n    const payload = await content;\n    return new HttpResponse(response.status, response.statusText, payload);\n  }\n\n  getCookieString(url) {\n    let cookies = \"\";\n\n    if (Platform.isNode && this._jar) {\n      // @ts-ignore: unused variable\n      this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\n    }\n\n    return cookies;\n  }\n\n}\n\nfunction deserializeContent(response, responseType) {\n  let content;\n\n  switch (responseType) {\n    case \"arraybuffer\":\n      content = response.arrayBuffer();\n      break;\n\n    case \"text\":\n      content = response.text();\n      break;\n\n    case \"blob\":\n    case \"document\":\n    case \"json\":\n      throw new Error(`${responseType} is not supported.`);\n\n    default:\n      content = response.text();\n      break;\n  }\n\n  return content;\n}","map":{"version":3,"sources":["../../src/FetchHttpClient.ts"],"names":[],"mappings":"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","sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\n// @ts-ignore: This will be removed from built files and is here to make the types available during dev work\r\nimport { CookieJar } from \"@types/tough-cookie\";\r\n\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { Platform, getGlobalThis } from \"./Utils\";\r\n\r\nexport class FetchHttpClient extends HttpClient {\r\n    private readonly _abortControllerType: { prototype: AbortController, new(): AbortController };\r\n    private readonly _fetchType: (input: RequestInfo, init?: RequestInit) => Promise<Response>;\r\n    private readonly _jar?: CookieJar;\r\n\r\n    private readonly _logger: ILogger;\r\n\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n        this._logger = logger;\r\n\r\n        if (typeof fetch === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n\r\n            // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\r\n            this._jar = new (requireFunc(\"tough-cookie\")).CookieJar();\r\n            this._fetchType = requireFunc(\"node-fetch\");\r\n\r\n            // node-fetch doesn't have a nice API for getting and setting cookies\r\n            // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\r\n            this._fetchType = requireFunc(\"fetch-cookie\")(this._fetchType, this._jar);\r\n        } else {\r\n            this._fetchType = fetch.bind(getGlobalThis());\r\n        }\r\n        if (typeof AbortController === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n\r\n            // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\r\n            this._abortControllerType = requireFunc(\"abort-controller\");\r\n        } else {\r\n            this._abortControllerType = AbortController;\r\n        }\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public async send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            throw new AbortError();\r\n        }\r\n\r\n        if (!request.method) {\r\n            throw new Error(\"No method defined.\");\r\n        }\r\n        if (!request.url) {\r\n            throw new Error(\"No url defined.\");\r\n        }\r\n\r\n        const abortController = new this._abortControllerType();\r\n\r\n        let error: any;\r\n        // Hook our abortSignal into the abort controller\r\n        if (request.abortSignal) {\r\n            request.abortSignal.onabort = () => {\r\n                abortController.abort();\r\n                error = new AbortError();\r\n            };\r\n        }\r\n\r\n        // If a timeout has been passed in, setup a timeout to call abort\r\n        // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\r\n        let timeoutId: any = null;\r\n        if (request.timeout) {\r\n            const msTimeout = request.timeout!;\r\n            timeoutId = setTimeout(() => {\r\n                abortController.abort();\r\n                this._logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                error = new TimeoutError();\r\n            }, msTimeout);\r\n        }\r\n\r\n        let response: Response;\r\n        try {\r\n            response = await this._fetchType(request.url!, {\r\n                body: request.content!,\r\n                cache: \"no-cache\",\r\n                credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\r\n                headers: {\r\n                    \"Content-Type\": \"text/plain;charset=UTF-8\",\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    ...request.headers,\r\n                },\r\n                method: request.method!,\r\n                mode: \"cors\",\r\n                redirect: \"follow\",\r\n                signal: abortController.signal,\r\n            });\r\n        } catch (e) {\r\n            if (error) {\r\n                throw error;\r\n            }\r\n            this._logger.log(\r\n                LogLevel.Warning,\r\n                `Error from HTTP request. ${e}.`,\r\n            );\r\n            throw e;\r\n        } finally {\r\n            if (timeoutId) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = null;\r\n            }\r\n        }\r\n\r\n        if (!response.ok) {\r\n            const errorMessage = await deserializeContent(response, \"text\") as string;\r\n            throw new HttpError(errorMessage || response.statusText, response.status);\r\n        }\r\n\r\n        const content = deserializeContent(response, request.responseType);\r\n        const payload = await content;\r\n\r\n        return new HttpResponse(\r\n            response.status,\r\n            response.statusText,\r\n            payload,\r\n        );\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        let cookies: string = \"\";\r\n        if (Platform.isNode && this._jar) {\r\n            // @ts-ignore: unused variable\r\n            this._jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\r\n        }\r\n        return cookies;\r\n    }\r\n}\r\n\r\nfunction deserializeContent(response: Response, responseType?: XMLHttpRequestResponseType): Promise<string | ArrayBuffer> {\r\n    let content;\r\n    switch (responseType) {\r\n        case \"arraybuffer\":\r\n            content = response.arrayBuffer();\r\n            break;\r\n        case \"text\":\r\n            content = response.text();\r\n            break;\r\n        case \"blob\":\r\n        case \"document\":\r\n        case \"json\":\r\n            throw new Error(`${responseType} is not supported.`);\r\n        default:\r\n            content = response.text();\r\n            break;\r\n    }\r\n\r\n    return content;\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}