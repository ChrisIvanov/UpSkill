{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _url = require(\"url\");\n\nvar _matcher = _interopRequireDefault(require(\"matcher\"));\n\nvar _errors = require(\"../errors\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst isUrlMatchingNoProxy = (subjectUrl, noProxy) => {\n  const subjectUrlTokens = (0, _url.parse)(subjectUrl);\n  const rules = noProxy.split(/[\\s,]+/);\n\n  for (const rule of rules) {\n    const ruleMatch = rule.replace(/^(?<leadingDot>\\.)/, '*').match(/^(?<hostname>.+?)(?::(?<port>\\d+))?$/);\n\n    if (!ruleMatch || !ruleMatch.groups) {\n      throw new _errors.UnexpectedStateError('Invalid NO_PROXY pattern.');\n    }\n\n    if (!ruleMatch.groups.hostname) {\n      throw new _errors.UnexpectedStateError('NO_PROXY entry pattern must include hostname. Use * to match any hostname.');\n    }\n\n    const hostnameIsMatch = _matcher.default.isMatch(subjectUrlTokens.hostname, ruleMatch.groups.hostname);\n\n    if (hostnameIsMatch && (!ruleMatch.groups || !ruleMatch.groups.port || subjectUrlTokens.port && subjectUrlTokens.port === ruleMatch.groups.port)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nvar _default = isUrlMatchingNoProxy;\nexports.default = _default;","map":{"version":3,"sources":["../../src/utilities/isUrlMatchingNoProxy.js"],"names":["subjectUrl","noProxy","subjectUrlTokens","rules","ruleMatch","rule","UnexpectedStateError","hostnameIsMatch","matcher"],"mappings":";;;;;;;AAEA,IAAA,IAAA,GAAA,OAAA,CAAA,KAAA,CAAA;;AAGA,IAAA,QAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,SAAA,CAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;;;;;;;8BAIgBA,U,EAAoBC,O,KAAoB;AACtD,QAAMC,gBAAgB,GAAG,CAAA,GAAA,IAAA,CAAA,KAAA,EAAzB,UAAyB,CAAzB;AAEA,QAAMC,KAAK,GAAGF,OAAO,CAAPA,KAAAA,CAAd,QAAcA,CAAd;;AAEA,OAAK,MAAL,IAAA,IAAA,KAAA,EAA0B;AACxB,UAAMG,SAAS,GAAGC,IAAI,CAAJA,OAAAA,CAAAA,oBAAAA,EAAAA,GAAAA,EAAAA,KAAAA,CAAlB,sCAAkBA,CAAlB;;AAIA,QAAI,CAAA,SAAA,IAAc,CAACD,SAAS,CAA5B,MAAA,EAAqC;AACnC,YAAM,IAAIE,OAAAA,CAAJ,oBAAA,CAAN,2BAAM,CAAN;AACD;;AAED,QAAI,CAACF,SAAS,CAATA,MAAAA,CAAL,QAAA,EAAgC;AAC9B,YAAM,IAAIE,OAAAA,CAAJ,oBAAA,CAAN,4EAAM,CAAN;AACD;;AAED,UAAMC,eAAe,GAAGC,QAAAA,CAAAA,OAAAA,CAAAA,OAAAA,CAAgBN,gBAAgB,CAAhCM,QAAAA,EAA2CJ,SAAS,CAATA,MAAAA,CAAnE,QAAwBI,CAAxB;;AAEA,QAAID,eAAe,KAAK,CAACH,SAAS,CAAV,MAAA,IAAqB,CAACA,SAAS,CAATA,MAAAA,CAAtB,IAAA,IAA+CF,gBAAgB,CAAhBA,IAAAA,IAAyBA,gBAAgB,CAAhBA,IAAAA,KAA0BE,SAAS,CAATA,MAAAA,CAA1H,IAAmB,CAAnB,EAAkJ;AAChJ,aAAA,IAAA;AACD;AACF;;AAED,SAAA,KAAA","sourcesContent":["// @flow\n\nimport {\n  parse as parseUrl,\n} from 'url';\nimport matcher from 'matcher';\nimport {\n  UnexpectedStateError,\n} from '../errors';\n\nexport default (subjectUrl: string, noProxy: string) => {\n  const subjectUrlTokens = parseUrl(subjectUrl);\n\n  const rules = noProxy.split(/[\\s,]+/);\n\n  for (const rule of rules) {\n    const ruleMatch = rule\n      .replace(/^(?<leadingDot>\\.)/, '*')\n      .match(/^(?<hostname>.+?)(?::(?<port>\\d+))?$/);\n\n    if (!ruleMatch || !ruleMatch.groups) {\n      throw new UnexpectedStateError('Invalid NO_PROXY pattern.');\n    }\n\n    if (!ruleMatch.groups.hostname) {\n      throw new UnexpectedStateError('NO_PROXY entry pattern must include hostname. Use * to match any hostname.');\n    }\n\n    const hostnameIsMatch = matcher.isMatch(subjectUrlTokens.hostname, ruleMatch.groups.hostname);\n\n    if (hostnameIsMatch && (!ruleMatch.groups || !ruleMatch.groups.port || subjectUrlTokens.port && subjectUrlTokens.port === ruleMatch.groups.port)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n"]},"metadata":{},"sourceType":"script"}