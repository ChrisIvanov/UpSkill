{"ast":null,"code":"// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\nimport { HeaderNames } from \"./HeaderNames\";\nimport { LogLevel } from \"./ILogger\";\nimport { TransferFormat } from \"./ITransport\";\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\n/** @private */\n\nexport class WebSocketTransport {\n  constructor(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor, headers) {\n    this._logger = logger;\n    this._accessTokenFactory = accessTokenFactory;\n    this._logMessageContent = logMessageContent;\n    this._webSocketConstructor = webSocketConstructor;\n    this._httpClient = httpClient;\n    this.onreceive = null;\n    this.onclose = null;\n    this._headers = headers;\n  }\n\n  async connect(url, transferFormat) {\n    Arg.isRequired(url, \"url\");\n    Arg.isRequired(transferFormat, \"transferFormat\");\n    Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n\n    this._logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\n\n    if (this._accessTokenFactory) {\n      const token = await this._accessTokenFactory();\n\n      if (token) {\n        url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\n      }\n    }\n\n    return new Promise((resolve, reject) => {\n      url = url.replace(/^http/, \"ws\");\n      let webSocket;\n\n      const cookies = this._httpClient.getCookieString(url);\n\n      let opened = false;\n\n      if (Platform.isNode) {\n        const headers = {};\n        const [name, value] = getUserAgentHeader();\n        headers[name] = value;\n\n        if (cookies) {\n          headers[HeaderNames.Cookie] = `${cookies}`;\n        } // Only pass headers when in non-browser environments\n\n\n        webSocket = new this._webSocketConstructor(url, undefined, {\n          headers: { ...headers,\n            ...this._headers\n          }\n        });\n      }\n\n      if (!webSocket) {\n        // Chrome is not happy with passing 'undefined' as protocol\n        webSocket = new this._webSocketConstructor(url);\n      }\n\n      if (transferFormat === TransferFormat.Binary) {\n        webSocket.binaryType = \"arraybuffer\";\n      }\n\n      webSocket.onopen = _event => {\n        this._logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\n\n        this._webSocket = webSocket;\n        opened = true;\n        resolve();\n      };\n\n      webSocket.onerror = event => {\n        let error = null; // ErrorEvent is a browser only type we need to check if the type exists before using it\n\n        if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n          error = event.error;\n        } else {\n          error = \"There was an error with the transport\";\n        }\n\n        this._logger.log(LogLevel.Information, `(WebSockets transport) ${error}.`);\n      };\n\n      webSocket.onmessage = message => {\n        this._logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this._logMessageContent)}.`);\n\n        if (this.onreceive) {\n          try {\n            this.onreceive(message.data);\n          } catch (error) {\n            this._close(error);\n\n            return;\n          }\n        }\n      };\n\n      webSocket.onclose = event => {\n        // Don't call close handler if connection was never established\n        // We'll reject the connect call instead\n        if (opened) {\n          this._close(event);\n        } else {\n          let error = null; // ErrorEvent is a browser only type we need to check if the type exists before using it\n\n          if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\n            error = event.error;\n          } else {\n            error = \"WebSocket failed to connect. The connection could not be found on the server,\" + \" either the endpoint may not be a SignalR endpoint,\" + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\" + \" If you have multiple servers check that sticky sessions are enabled.\";\n          }\n\n          reject(new Error(error));\n        }\n      };\n    });\n  }\n\n  send(data) {\n    if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\n      this._logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this._logMessageContent)}.`);\n\n      this._webSocket.send(data);\n\n      return Promise.resolve();\n    }\n\n    return Promise.reject(\"WebSocket is not in the OPEN state\");\n  }\n\n  stop() {\n    if (this._webSocket) {\n      // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\n      // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\n      this._close(undefined);\n    }\n\n    return Promise.resolve();\n  }\n\n  _close(event) {\n    // webSocket will be null if the transport did not start successfully\n    if (this._webSocket) {\n      // Clear websocket handlers because we are considering the socket closed now\n      this._webSocket.onclose = () => {};\n\n      this._webSocket.onmessage = () => {};\n\n      this._webSocket.onerror = () => {};\n\n      this._webSocket.close();\n\n      this._webSocket = undefined;\n    }\n\n    this._logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\n\n    if (this.onclose) {\n      if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\n        this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || \"no reason given\"}).`));\n      } else if (event instanceof Error) {\n        this.onclose(event);\n      } else {\n        this.onclose();\n      }\n    }\n  }\n\n  _isCloseEvent(event) {\n    return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\n  }\n\n}","map":{"version":3,"sources":["../../src/WebSocketTransport.ts"],"names":[],"mappings":"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","sourcesContent":["// Licensed to the .NET Foundation under one or more agreements.\r\n// The .NET Foundation licenses this file to you under the MIT license.\r\n\r\nimport { HeaderNames } from \"./HeaderNames\";\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { MessageHeaders } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { ITransport, TransferFormat } from \"./ITransport\";\r\nimport { WebSocketConstructor } from \"./Polyfills\";\r\nimport { Arg, getDataDetail, getUserAgentHeader, Platform } from \"./Utils\";\r\n\r\n/** @private */\r\nexport class WebSocketTransport implements ITransport {\r\n    private readonly _logger: ILogger;\r\n    private readonly _accessTokenFactory: (() => string | Promise<string>) | undefined;\r\n    private readonly _logMessageContent: boolean;\r\n    private readonly _webSocketConstructor: WebSocketConstructor;\r\n    private readonly _httpClient: HttpClient;\r\n    private _webSocket?: WebSocket;\r\n    private _headers: MessageHeaders;\r\n\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((error?: Error) => void) | null;\r\n\r\n    constructor(httpClient: HttpClient, accessTokenFactory: (() => string | Promise<string>) | undefined, logger: ILogger,\r\n                logMessageContent: boolean, webSocketConstructor: WebSocketConstructor, headers: MessageHeaders) {\r\n        this._logger = logger;\r\n        this._accessTokenFactory = accessTokenFactory;\r\n        this._logMessageContent = logMessageContent;\r\n        this._webSocketConstructor = webSocketConstructor;\r\n        this._httpClient = httpClient;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n        this._headers = headers;\r\n    }\r\n\r\n    public async connect(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        Arg.isRequired(url, \"url\");\r\n        Arg.isRequired(transferFormat, \"transferFormat\");\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) Connecting.\");\r\n\r\n        if (this._accessTokenFactory) {\r\n            const token = await this._accessTokenFactory();\r\n            if (token) {\r\n                url += (url.indexOf(\"?\") < 0 ? \"?\" : \"&\") + `access_token=${encodeURIComponent(token)}`;\r\n            }\r\n        }\r\n\r\n        return new Promise<void>((resolve, reject) => {\r\n            url = url.replace(/^http/, \"ws\");\r\n            let webSocket: WebSocket | undefined;\r\n            const cookies = this._httpClient.getCookieString(url);\r\n            let opened = false;\r\n\r\n            if (Platform.isNode) {\r\n                const headers: {[k: string]: string} = {};\r\n                const [name, value] = getUserAgentHeader();\r\n                headers[name] = value;\r\n\r\n                if (cookies) {\r\n                    headers[HeaderNames.Cookie] = `${cookies}`;\r\n                }\r\n\r\n                // Only pass headers when in non-browser environments\r\n                webSocket = new this._webSocketConstructor(url, undefined, {\r\n                    headers: { ...headers, ...this._headers },\r\n                });\r\n            }\r\n\r\n            if (!webSocket) {\r\n                // Chrome is not happy with passing 'undefined' as protocol\r\n                webSocket = new this._webSocketConstructor(url);\r\n            }\r\n\r\n            if (transferFormat === TransferFormat.Binary) {\r\n                webSocket.binaryType = \"arraybuffer\";\r\n            }\r\n\r\n            webSocket.onopen = (_event: Event) => {\r\n                this._logger.log(LogLevel.Information, `WebSocket connected to ${url}.`);\r\n                this._webSocket = webSocket;\r\n                opened = true;\r\n                resolve();\r\n            };\r\n\r\n            webSocket.onerror = (event: Event) => {\r\n                let error: any = null;\r\n                // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                    error = event.error;\r\n                } else {\r\n                    error = \"There was an error with the transport\";\r\n                }\r\n\r\n                this._logger.log(LogLevel.Information, `(WebSockets transport) ${error}.`);\r\n            };\r\n\r\n            webSocket.onmessage = (message: MessageEvent) => {\r\n                this._logger.log(LogLevel.Trace, `(WebSockets transport) data received. ${getDataDetail(message.data, this._logMessageContent)}.`);\r\n                if (this.onreceive) {\r\n                    try {\r\n                        this.onreceive(message.data);\r\n                    } catch (error) {\r\n                        this._close(error);\r\n                        return;\r\n                    }\r\n                }\r\n            };\r\n\r\n            webSocket.onclose = (event: CloseEvent) => {\r\n                // Don't call close handler if connection was never established\r\n                // We'll reject the connect call instead\r\n                if (opened) {\r\n                    this._close(event);\r\n                } else {\r\n                    let error: any = null;\r\n                    // ErrorEvent is a browser only type we need to check if the type exists before using it\r\n                    if (typeof ErrorEvent !== \"undefined\" && event instanceof ErrorEvent) {\r\n                        error = event.error;\r\n                    } else {\r\n                        error = \"WebSocket failed to connect. The connection could not be found on the server,\"\r\n                        + \" either the endpoint may not be a SignalR endpoint,\"\r\n                        + \" the connection ID is not present on the server, or there is a proxy blocking WebSockets.\"\r\n                        + \" If you have multiple servers check that sticky sessions are enabled.\";\r\n                    }\r\n\r\n                    reject(new Error(error));\r\n                }\r\n            };\r\n        });\r\n    }\r\n\r\n    public send(data: any): Promise<void> {\r\n        if (this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN) {\r\n            this._logger.log(LogLevel.Trace, `(WebSockets transport) sending data. ${getDataDetail(data, this._logMessageContent)}.`);\r\n            this._webSocket.send(data);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return Promise.reject(\"WebSocket is not in the OPEN state\");\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        if (this._webSocket) {\r\n            // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning\r\n            // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects\r\n            this._close(undefined);\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    private _close(event?: CloseEvent | Error): void {\r\n        // webSocket will be null if the transport did not start successfully\r\n        if (this._webSocket) {\r\n            // Clear websocket handlers because we are considering the socket closed now\r\n            this._webSocket.onclose = () => {};\r\n            this._webSocket.onmessage = () => {};\r\n            this._webSocket.onerror = () => {};\r\n            this._webSocket.close();\r\n            this._webSocket = undefined;\r\n        }\r\n\r\n        this._logger.log(LogLevel.Trace, \"(WebSockets transport) socket closed.\");\r\n        if (this.onclose) {\r\n            if (this._isCloseEvent(event) && (event.wasClean === false || event.code !== 1000)) {\r\n                this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason || \"no reason given\"}).`));\r\n            } else if (event instanceof Error) {\r\n                this.onclose(event);\r\n            } else {\r\n                this.onclose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _isCloseEvent(event?: any): event is CloseEvent {\r\n        return event && typeof event.wasClean === \"boolean\" && typeof event.code === \"number\";\r\n    }\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}