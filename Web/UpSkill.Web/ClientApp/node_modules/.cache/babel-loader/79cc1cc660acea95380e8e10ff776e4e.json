{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.composeServices = exports.addFederationMetadataToSchemaNodes = exports.buildSchemaFromDefinitionsAndExtensions = exports.buildMapsFromServiceList = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst apollo_graphql_1 = require(\"apollo-graphql\");\n\nconst directives_1 = __importStar(require(\"../directives\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst validate_1 = require(\"graphql/validation/validate\");\n\nconst rules_1 = require(\"./rules\");\n\nconst printSupergraphSdl_1 = require(\"../service/printSupergraphSdl\");\n\nconst utilities_1 = require(\"../utilities\");\n\nconst EmptyQueryDefinition = {\n  kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n  name: {\n    kind: graphql_1.Kind.NAME,\n    value: utils_1.defaultRootOperationNameLookup.query\n  },\n  fields: [],\n  serviceName: null\n};\nconst EmptyMutationDefinition = {\n  kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n  name: {\n    kind: graphql_1.Kind.NAME,\n    value: utils_1.defaultRootOperationNameLookup.mutation\n  },\n  fields: [],\n  serviceName: null\n};\n\nfunction buildMapsFromServiceList(serviceList) {\n  var _a;\n\n  const typeDefinitionsMap = Object.create(null);\n  const typeExtensionsMap = Object.create(null);\n  const directiveDefinitionsMap = Object.create(null);\n  const typeToServiceMap = Object.create(null);\n  const externalFields = [];\n  const keyDirectivesMap = Object.create(null);\n  const valueTypes = new Set();\n  const typeNameToFieldDirectivesMap = new Map();\n  const otherKnownDirectiveUsages = new Set();\n\n  for (const {\n    typeDefs,\n    name: serviceName\n  } of serviceList) {\n    const {\n      typeDefsWithoutExternalFields,\n      strippedFields\n    } = utils_1.stripExternalFieldsFromTypeDefs(typeDefs, serviceName);\n    externalFields.push(...strippedFields);\n    const typeDefsWithoutTypeSystemDirectives = utils_1.stripTypeSystemDirectivesFromTypeDefs(typeDefsWithoutExternalFields);\n\n    for (const definition of typeDefsWithoutTypeSystemDirectives.definitions) {\n      if (definition.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || definition.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION) {\n        const typeName = definition.name.value;\n\n        for (const keyDirective of utils_1.findDirectivesOnNode(definition, 'key')) {\n          if (keyDirective.arguments && utils_1.isStringValueNode(keyDirective.arguments[0].value)) {\n            keyDirectivesMap[typeName] = keyDirectivesMap[typeName] || {};\n            keyDirectivesMap[typeName][serviceName] = keyDirectivesMap[typeName][serviceName] || [];\n            keyDirectivesMap[typeName][serviceName].push(utils_1.parseSelections(keyDirective.arguments[0].value.value));\n          }\n        }\n\n        for (const field of (_a = definition.fields) !== null && _a !== void 0 ? _a : []) {\n          captureTagUsages(field, typeName, typeNameToFieldDirectivesMap, otherKnownDirectiveUsages);\n        }\n      }\n\n      if (graphql_1.isTypeDefinitionNode(definition)) {\n        const typeName = definition.name.value;\n\n        if (!typeToServiceMap[typeName]) {\n          typeToServiceMap[typeName] = {\n            extensionFieldsToOwningServiceMap: Object.create(null)\n          };\n        }\n\n        typeToServiceMap[typeName].owningService = serviceName;\n\n        if (typeDefinitionsMap[typeName]) {\n          const isValueType = utils_1.typeNodesAreEquivalent(typeDefinitionsMap[typeName][typeDefinitionsMap[typeName].length - 1], definition);\n\n          if (isValueType) {\n            valueTypes.add(typeName);\n          }\n\n          typeDefinitionsMap[typeName].push({ ...definition,\n            serviceName\n          });\n        } else {\n          typeDefinitionsMap[typeName] = [{ ...definition,\n            serviceName\n          }];\n        }\n      } else if (graphql_1.isTypeExtensionNode(definition)) {\n        const typeName = definition.name.value;\n\n        if (definition.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION || definition.kind === graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION) {\n          if (!definition.fields) break;\n          const fields = utils_1.mapFieldNamesToServiceName(definition.fields, serviceName);\n\n          if (typeToServiceMap[typeName]) {\n            typeToServiceMap[typeName].extensionFieldsToOwningServiceMap = { ...typeToServiceMap[typeName].extensionFieldsToOwningServiceMap,\n              ...fields\n            };\n          } else {\n            typeToServiceMap[typeName] = {\n              extensionFieldsToOwningServiceMap: fields\n            };\n          }\n        }\n\n        if (definition.kind === graphql_1.Kind.ENUM_TYPE_EXTENSION) {\n          if (!definition.values) break;\n          const values = utils_1.mapFieldNamesToServiceName(definition.values, serviceName);\n\n          if (typeToServiceMap[typeName]) {\n            typeToServiceMap[typeName].extensionFieldsToOwningServiceMap = { ...typeToServiceMap[typeName].extensionFieldsToOwningServiceMap,\n              ...values\n            };\n          } else {\n            typeToServiceMap[typeName] = {\n              extensionFieldsToOwningServiceMap: values\n            };\n          }\n        }\n\n        if (typeExtensionsMap[typeName]) {\n          typeExtensionsMap[typeName].push({ ...definition,\n            serviceName\n          });\n        } else {\n          typeExtensionsMap[typeName] = [{ ...definition,\n            serviceName\n          }];\n        }\n      } else if (utils_1.isDirectiveDefinitionNode(definition)) {\n        const directiveName = definition.name.value;\n        const executableLocations = definition.locations.filter(location => utils_1.executableDirectiveLocations.includes(location.value));\n        if (executableLocations.length === 0) continue;\n        const definitionWithExecutableLocations = { ...definition,\n          locations: executableLocations\n        };\n\n        if (directiveDefinitionsMap[directiveName]) {\n          directiveDefinitionsMap[directiveName][serviceName] = definitionWithExecutableLocations;\n        } else {\n          directiveDefinitionsMap[directiveName] = {\n            [serviceName]: definitionWithExecutableLocations\n          };\n        }\n      }\n    }\n  }\n\n  for (const {\n    parentTypeName,\n    field\n  } of externalFields) {\n    captureTagUsages(field, parentTypeName, typeNameToFieldDirectivesMap, otherKnownDirectiveUsages);\n  }\n\n  if (!typeDefinitionsMap.Query) typeDefinitionsMap.Query = [EmptyQueryDefinition];\n  if (typeExtensionsMap.Mutation && !typeDefinitionsMap.Mutation) typeDefinitionsMap.Mutation = [EmptyMutationDefinition];\n  return {\n    typeToServiceMap,\n    typeDefinitionsMap,\n    typeExtensionsMap,\n    directiveDefinitionsMap,\n    externalFields,\n    keyDirectivesMap,\n    valueTypes,\n    typeNameToFieldDirectivesMap,\n    otherKnownDirectiveUsages\n  };\n}\n\nexports.buildMapsFromServiceList = buildMapsFromServiceList;\n\nfunction captureTagUsages(field, typeName, typeNameToFieldDirectivesMap, otherKnownDirectiveUsages) {\n  const tagUsages = utils_1.findDirectivesOnNode(field, 'tag');\n\n  if (tagUsages.length > 0) {\n    otherKnownDirectiveUsages.add('tag');\n    const fieldToDirectivesMap = utilities_1.mapGetOrSet(typeNameToFieldDirectivesMap, typeName, new Map());\n    const directives = utilities_1.mapGetOrSet(fieldToDirectivesMap, field.name.value, []);\n    directives.push(...tagUsages);\n  }\n}\n\nfunction buildSchemaFromDefinitionsAndExtensions({\n  typeDefinitionsMap,\n  typeExtensionsMap,\n  directiveDefinitionsMap,\n  otherKnownDirectiveUsages\n}) {\n  let errors = undefined;\n  const otherKnownDirectiveDefinitionsToInclude = directives_1.otherKnownDirectiveDefinitions.filter(directive => otherKnownDirectiveUsages.has(directive.name));\n  let schema = new graphql_1.GraphQLSchema({\n    query: undefined,\n    directives: [...graphql_1.specifiedDirectives, ...directives_1.federationDirectives, ...otherKnownDirectiveDefinitionsToInclude]\n  });\n\n  function nodeHasInterfaces(node) {\n    return 'interfaces' in node;\n  }\n\n  const definitionsDocument = {\n    kind: graphql_1.Kind.DOCUMENT,\n    definitions: [...Object.values(typeDefinitionsMap).flatMap(typeDefinitions => {\n      if (!typeDefinitions.some(nodeHasInterfaces)) return typeDefinitions;\n      const uniqueInterfaces = typeDefinitions.reduce((map, objectTypeDef) => {\n        var _a;\n\n        (_a = objectTypeDef.interfaces) === null || _a === void 0 ? void 0 : _a.forEach(iface => map.set(iface.name.value, iface));\n        return map;\n      }, new Map());\n      if (uniqueInterfaces.size === 0) return typeDefinitions;\n      const [first, ...rest] = typeDefinitions;\n      return [...rest, { ...first,\n        interfaces: Array.from(uniqueInterfaces.values())\n      }];\n    }), ...Object.values(directiveDefinitionsMap).map(definitions => Object.values(definitions)[0])]\n  };\n  errors = validate_1.validateSDL(definitionsDocument, schema, rules_1.compositionRules);\n\n  try {\n    schema = graphql_1.extendSchema(schema, definitionsDocument, {\n      assumeValidSDL: true\n    });\n  } catch (e) {}\n\n  const extensionsDocument = {\n    kind: graphql_1.Kind.DOCUMENT,\n    definitions: Object.values(typeExtensionsMap).flat()\n  };\n  errors.push(...validate_1.validateSDL(extensionsDocument, schema, rules_1.compositionRules));\n\n  try {\n    schema = graphql_1.extendSchema(schema, extensionsDocument, {\n      assumeValidSDL: true\n    });\n  } catch {}\n\n  schema = new graphql_1.GraphQLSchema({ ...schema.toConfig(),\n    directives: [...schema.getDirectives().filter(x => !utils_1.isFederationDirective(x))]\n  });\n  return {\n    schema,\n    errors\n  };\n}\n\nexports.buildSchemaFromDefinitionsAndExtensions = buildSchemaFromDefinitionsAndExtensions;\n\nfunction addFederationMetadataToSchemaNodes({\n  schema,\n  typeToServiceMap,\n  externalFields,\n  keyDirectivesMap,\n  valueTypes,\n  directiveDefinitionsMap,\n  typeNameToFieldDirectivesMap\n}) {\n  var _a;\n\n  for (const [typeName, {\n    owningService,\n    extensionFieldsToOwningServiceMap\n  }] of Object.entries(typeToServiceMap)) {\n    const namedType = schema.getType(typeName);\n    if (!namedType) continue;\n    const isValueType = valueTypes.has(typeName);\n    const serviceName = isValueType ? null : owningService;\n    const federationMetadata = { ...utils_1.getFederationMetadata(namedType),\n      serviceName,\n      isValueType,\n      ...(keyDirectivesMap[typeName] && {\n        keys: keyDirectivesMap[typeName]\n      })\n    };\n    namedType.extensions = { ...namedType.extensions,\n      federation: federationMetadata\n    };\n\n    if (graphql_1.isObjectType(namedType)) {\n      for (const field of Object.values(namedType.getFields())) {\n        const [providesDirective] = utils_1.findDirectivesOnNode(field.astNode, 'provides');\n\n        if (providesDirective && providesDirective.arguments && utils_1.isStringValueNode(providesDirective.arguments[0].value)) {\n          const fieldFederationMetadata = { ...utils_1.getFederationMetadata(field),\n            serviceName,\n            provides: utils_1.parseSelections(providesDirective.arguments[0].value.value),\n            belongsToValueType: isValueType\n          };\n          field.extensions = { ...field.extensions,\n            federation: fieldFederationMetadata\n          };\n        }\n      }\n    }\n\n    for (const [fieldName, extendingServiceName] of Object.entries(extensionFieldsToOwningServiceMap)) {\n      if (graphql_1.isObjectType(namedType)) {\n        const field = namedType.getFields()[fieldName];\n        if (!field) continue;\n        const fieldFederationMetadata = { ...utils_1.getFederationMetadata(field),\n          serviceName: extendingServiceName\n        };\n        field.extensions = { ...field.extensions,\n          federation: fieldFederationMetadata\n        };\n        const [requiresDirective] = utils_1.findDirectivesOnNode(field.astNode, 'requires');\n\n        if (requiresDirective && requiresDirective.arguments && utils_1.isStringValueNode(requiresDirective.arguments[0].value)) {\n          const fieldFederationMetadata = { ...utils_1.getFederationMetadata(field),\n            requires: utils_1.parseSelections(requiresDirective.arguments[0].value.value)\n          };\n          field.extensions = { ...field.extensions,\n            federation: fieldFederationMetadata\n          };\n        }\n      }\n    }\n  }\n\n  for (const field of externalFields) {\n    const namedType = schema.getType(field.parentTypeName);\n    if (!namedType) continue;\n    const existingMetadata = utils_1.getFederationMetadata(namedType);\n    const typeFederationMetadata = { ...existingMetadata,\n      externals: { ...(existingMetadata === null || existingMetadata === void 0 ? void 0 : existingMetadata.externals),\n        [field.serviceName]: [...(((_a = existingMetadata === null || existingMetadata === void 0 ? void 0 : existingMetadata.externals) === null || _a === void 0 ? void 0 : _a[field.serviceName]) || []), field]\n      }\n    };\n    namedType.extensions = { ...namedType.extensions,\n      federation: typeFederationMetadata\n    };\n  }\n\n  for (const directiveName of Object.keys(directiveDefinitionsMap)) {\n    const directive = schema.getDirective(directiveName);\n    if (!directive) continue;\n    const directiveFederationMetadata = { ...utils_1.getFederationMetadata(directive),\n      directiveDefinitions: directiveDefinitionsMap[directiveName]\n    };\n    directive.extensions = { ...directive.extensions,\n      federation: directiveFederationMetadata\n    };\n  }\n\n  for (const [typeName, fieldsToDirectivesMap] of typeNameToFieldDirectivesMap.entries()) {\n    const type = schema.getType(typeName);\n    if (!type) continue;\n\n    for (const [fieldName, otherKnownDirectiveUsages] of fieldsToDirectivesMap.entries()) {\n      const field = type.getFields()[fieldName];\n      const seenNonRepeatableDirectives = {};\n      const filteredDirectives = otherKnownDirectiveUsages.filter(directive => {\n        const name = directive.name.value;\n        const matchingDirective = directives_1.default.find(d => d.name === name);\n        if (matchingDirective === null || matchingDirective === void 0 ? void 0 : matchingDirective.isRepeatable) return true;\n        if (seenNonRepeatableDirectives[name]) return false;\n        seenNonRepeatableDirectives[name] = true;\n        return true;\n      });\n      const existingMetadata = utils_1.getFederationMetadata(field);\n      const fieldFederationMetadata = { ...existingMetadata,\n        otherKnownDirectiveUsages: filteredDirectives\n      };\n      field.extensions = { ...field.extensions,\n        federation: fieldFederationMetadata\n      };\n    }\n  }\n}\n\nexports.addFederationMetadataToSchemaNodes = addFederationMetadataToSchemaNodes;\n\nfunction composeServices(services) {\n  const {\n    typeToServiceMap,\n    typeDefinitionsMap,\n    typeExtensionsMap,\n    directiveDefinitionsMap,\n    externalFields,\n    keyDirectivesMap,\n    valueTypes,\n    typeNameToFieldDirectivesMap,\n    otherKnownDirectiveUsages\n  } = buildMapsFromServiceList(services);\n  let {\n    schema,\n    errors\n  } = buildSchemaFromDefinitionsAndExtensions({\n    typeDefinitionsMap,\n    typeExtensionsMap,\n    directiveDefinitionsMap,\n    otherKnownDirectiveUsages\n  });\n  schema = new graphql_1.GraphQLSchema({ ...schema.toConfig(),\n    ...utilities_1.mapValues(utils_1.defaultRootOperationNameLookup, typeName => typeName ? schema.getType(typeName) : undefined),\n    extensions: {\n      serviceList: services\n    }\n  });\n  schema = apollo_graphql_1.transformSchema(schema, type => {\n    if (graphql_1.isObjectType(type)) {\n      const config = type.toConfig();\n      return new graphql_1.GraphQLObjectType({ ...config,\n        interfaces: Array.from(new Set(config.interfaces))\n      });\n    }\n\n    return undefined;\n  });\n  schema = graphql_1.lexicographicSortSchema(schema);\n  addFederationMetadataToSchemaNodes({\n    schema,\n    typeToServiceMap,\n    externalFields,\n    keyDirectivesMap,\n    valueTypes,\n    directiveDefinitionsMap,\n    typeNameToFieldDirectivesMap\n  });\n\n  if (errors.length > 0) {\n    return {\n      schema,\n      errors\n    };\n  } else {\n    return {\n      schema,\n      supergraphSdl: printSupergraphSdl_1.printSupergraphSdl(schema, services)\n    };\n  }\n}\n\nexports.composeServices = composeServices;","map":{"version":3,"sources":["../../src/composition/compose.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.composeServices = exports.addFederationMetadataToSchemaNodes = exports.buildSchemaFromDefinitionsAndExtensions = exports.buildMapsFromServiceList = void 0;\nconst graphql_1 = require(\"graphql\");\nconst apollo_graphql_1 = require(\"apollo-graphql\");\nconst directives_1 = __importStar(require(\"../directives\"));\nconst utils_1 = require(\"./utils\");\nconst validate_1 = require(\"graphql/validation/validate\");\nconst rules_1 = require(\"./rules\");\nconst printSupergraphSdl_1 = require(\"../service/printSupergraphSdl\");\nconst utilities_1 = require(\"../utilities\");\nconst EmptyQueryDefinition = {\n    kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n    name: { kind: graphql_1.Kind.NAME, value: utils_1.defaultRootOperationNameLookup.query },\n    fields: [],\n    serviceName: null,\n};\nconst EmptyMutationDefinition = {\n    kind: graphql_1.Kind.OBJECT_TYPE_DEFINITION,\n    name: { kind: graphql_1.Kind.NAME, value: utils_1.defaultRootOperationNameLookup.mutation },\n    fields: [],\n    serviceName: null,\n};\nfunction buildMapsFromServiceList(serviceList) {\n    var _a;\n    const typeDefinitionsMap = Object.create(null);\n    const typeExtensionsMap = Object.create(null);\n    const directiveDefinitionsMap = Object.create(null);\n    const typeToServiceMap = Object.create(null);\n    const externalFields = [];\n    const keyDirectivesMap = Object.create(null);\n    const valueTypes = new Set();\n    const typeNameToFieldDirectivesMap = new Map();\n    const otherKnownDirectiveUsages = new Set();\n    for (const { typeDefs, name: serviceName } of serviceList) {\n        const { typeDefsWithoutExternalFields, strippedFields, } = utils_1.stripExternalFieldsFromTypeDefs(typeDefs, serviceName);\n        externalFields.push(...strippedFields);\n        const typeDefsWithoutTypeSystemDirectives = utils_1.stripTypeSystemDirectivesFromTypeDefs(typeDefsWithoutExternalFields);\n        for (const definition of typeDefsWithoutTypeSystemDirectives.definitions) {\n            if (definition.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION ||\n                definition.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION) {\n                const typeName = definition.name.value;\n                for (const keyDirective of utils_1.findDirectivesOnNode(definition, 'key')) {\n                    if (keyDirective.arguments &&\n                        utils_1.isStringValueNode(keyDirective.arguments[0].value)) {\n                        keyDirectivesMap[typeName] = keyDirectivesMap[typeName] || {};\n                        keyDirectivesMap[typeName][serviceName] =\n                            keyDirectivesMap[typeName][serviceName] || [];\n                        keyDirectivesMap[typeName][serviceName].push(utils_1.parseSelections(keyDirective.arguments[0].value.value));\n                    }\n                }\n                for (const field of (_a = definition.fields) !== null && _a !== void 0 ? _a : []) {\n                    captureTagUsages(field, typeName, typeNameToFieldDirectivesMap, otherKnownDirectiveUsages);\n                }\n            }\n            if (graphql_1.isTypeDefinitionNode(definition)) {\n                const typeName = definition.name.value;\n                if (!typeToServiceMap[typeName]) {\n                    typeToServiceMap[typeName] = {\n                        extensionFieldsToOwningServiceMap: Object.create(null),\n                    };\n                }\n                typeToServiceMap[typeName].owningService = serviceName;\n                if (typeDefinitionsMap[typeName]) {\n                    const isValueType = utils_1.typeNodesAreEquivalent(typeDefinitionsMap[typeName][typeDefinitionsMap[typeName].length - 1], definition);\n                    if (isValueType) {\n                        valueTypes.add(typeName);\n                    }\n                    typeDefinitionsMap[typeName].push({ ...definition, serviceName });\n                }\n                else {\n                    typeDefinitionsMap[typeName] = [{ ...definition, serviceName }];\n                }\n            }\n            else if (graphql_1.isTypeExtensionNode(definition)) {\n                const typeName = definition.name.value;\n                if (definition.kind === graphql_1.Kind.OBJECT_TYPE_EXTENSION ||\n                    definition.kind === graphql_1.Kind.INPUT_OBJECT_TYPE_EXTENSION) {\n                    if (!definition.fields)\n                        break;\n                    const fields = utils_1.mapFieldNamesToServiceName(definition.fields, serviceName);\n                    if (typeToServiceMap[typeName]) {\n                        typeToServiceMap[typeName].extensionFieldsToOwningServiceMap = {\n                            ...typeToServiceMap[typeName].extensionFieldsToOwningServiceMap,\n                            ...fields,\n                        };\n                    }\n                    else {\n                        typeToServiceMap[typeName] = {\n                            extensionFieldsToOwningServiceMap: fields,\n                        };\n                    }\n                }\n                if (definition.kind === graphql_1.Kind.ENUM_TYPE_EXTENSION) {\n                    if (!definition.values)\n                        break;\n                    const values = utils_1.mapFieldNamesToServiceName(definition.values, serviceName);\n                    if (typeToServiceMap[typeName]) {\n                        typeToServiceMap[typeName].extensionFieldsToOwningServiceMap = {\n                            ...typeToServiceMap[typeName].extensionFieldsToOwningServiceMap,\n                            ...values,\n                        };\n                    }\n                    else {\n                        typeToServiceMap[typeName] = {\n                            extensionFieldsToOwningServiceMap: values,\n                        };\n                    }\n                }\n                if (typeExtensionsMap[typeName]) {\n                    typeExtensionsMap[typeName].push({ ...definition, serviceName });\n                }\n                else {\n                    typeExtensionsMap[typeName] = [{ ...definition, serviceName }];\n                }\n            }\n            else if (utils_1.isDirectiveDefinitionNode(definition)) {\n                const directiveName = definition.name.value;\n                const executableLocations = definition.locations.filter(location => utils_1.executableDirectiveLocations.includes(location.value));\n                if (executableLocations.length === 0)\n                    continue;\n                const definitionWithExecutableLocations = {\n                    ...definition,\n                    locations: executableLocations,\n                };\n                if (directiveDefinitionsMap[directiveName]) {\n                    directiveDefinitionsMap[directiveName][serviceName] = definitionWithExecutableLocations;\n                }\n                else {\n                    directiveDefinitionsMap[directiveName] = {\n                        [serviceName]: definitionWithExecutableLocations,\n                    };\n                }\n            }\n        }\n    }\n    for (const { parentTypeName, field } of externalFields) {\n        captureTagUsages(field, parentTypeName, typeNameToFieldDirectivesMap, otherKnownDirectiveUsages);\n    }\n    if (!typeDefinitionsMap.Query)\n        typeDefinitionsMap.Query = [EmptyQueryDefinition];\n    if (typeExtensionsMap.Mutation && !typeDefinitionsMap.Mutation)\n        typeDefinitionsMap.Mutation = [EmptyMutationDefinition];\n    return {\n        typeToServiceMap,\n        typeDefinitionsMap,\n        typeExtensionsMap,\n        directiveDefinitionsMap,\n        externalFields,\n        keyDirectivesMap,\n        valueTypes,\n        typeNameToFieldDirectivesMap,\n        otherKnownDirectiveUsages,\n    };\n}\nexports.buildMapsFromServiceList = buildMapsFromServiceList;\nfunction captureTagUsages(field, typeName, typeNameToFieldDirectivesMap, otherKnownDirectiveUsages) {\n    const tagUsages = utils_1.findDirectivesOnNode(field, 'tag');\n    if (tagUsages.length > 0) {\n        otherKnownDirectiveUsages.add('tag');\n        const fieldToDirectivesMap = utilities_1.mapGetOrSet(typeNameToFieldDirectivesMap, typeName, new Map());\n        const directives = utilities_1.mapGetOrSet(fieldToDirectivesMap, field.name.value, []);\n        directives.push(...tagUsages);\n    }\n}\nfunction buildSchemaFromDefinitionsAndExtensions({ typeDefinitionsMap, typeExtensionsMap, directiveDefinitionsMap, otherKnownDirectiveUsages, }) {\n    let errors = undefined;\n    const otherKnownDirectiveDefinitionsToInclude = directives_1.otherKnownDirectiveDefinitions.filter((directive) => otherKnownDirectiveUsages.has(directive.name));\n    let schema = new graphql_1.GraphQLSchema({\n        query: undefined,\n        directives: [\n            ...graphql_1.specifiedDirectives,\n            ...directives_1.federationDirectives,\n            ...otherKnownDirectiveDefinitionsToInclude,\n        ],\n    });\n    function nodeHasInterfaces(node) {\n        return 'interfaces' in node;\n    }\n    const definitionsDocument = {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: [\n            ...Object.values(typeDefinitionsMap).flatMap((typeDefinitions) => {\n                if (!typeDefinitions.some(nodeHasInterfaces))\n                    return typeDefinitions;\n                const uniqueInterfaces = typeDefinitions.reduce((map, objectTypeDef) => {\n                    var _a;\n                    (_a = objectTypeDef.interfaces) === null || _a === void 0 ? void 0 : _a.forEach((iface) => map.set(iface.name.value, iface));\n                    return map;\n                }, new Map());\n                if (uniqueInterfaces.size === 0)\n                    return typeDefinitions;\n                const [first, ...rest] = typeDefinitions;\n                return [\n                    ...rest,\n                    {\n                        ...first,\n                        interfaces: Array.from(uniqueInterfaces.values()),\n                    },\n                ];\n            }),\n            ...Object.values(directiveDefinitionsMap).map((definitions) => Object.values(definitions)[0]),\n        ],\n    };\n    errors = validate_1.validateSDL(definitionsDocument, schema, rules_1.compositionRules);\n    try {\n        schema = graphql_1.extendSchema(schema, definitionsDocument, {\n            assumeValidSDL: true,\n        });\n    }\n    catch (e) { }\n    const extensionsDocument = {\n        kind: graphql_1.Kind.DOCUMENT,\n        definitions: Object.values(typeExtensionsMap).flat(),\n    };\n    errors.push(...validate_1.validateSDL(extensionsDocument, schema, rules_1.compositionRules));\n    try {\n        schema = graphql_1.extendSchema(schema, extensionsDocument, {\n            assumeValidSDL: true,\n        });\n    }\n    catch { }\n    schema = new graphql_1.GraphQLSchema({\n        ...schema.toConfig(),\n        directives: [\n            ...schema.getDirectives().filter((x) => !utils_1.isFederationDirective(x)),\n        ],\n    });\n    return { schema, errors };\n}\nexports.buildSchemaFromDefinitionsAndExtensions = buildSchemaFromDefinitionsAndExtensions;\nfunction addFederationMetadataToSchemaNodes({ schema, typeToServiceMap, externalFields, keyDirectivesMap, valueTypes, directiveDefinitionsMap, typeNameToFieldDirectivesMap, }) {\n    var _a;\n    for (const [typeName, { owningService, extensionFieldsToOwningServiceMap },] of Object.entries(typeToServiceMap)) {\n        const namedType = schema.getType(typeName);\n        if (!namedType)\n            continue;\n        const isValueType = valueTypes.has(typeName);\n        const serviceName = isValueType ? null : owningService;\n        const federationMetadata = {\n            ...utils_1.getFederationMetadata(namedType),\n            serviceName,\n            isValueType,\n            ...(keyDirectivesMap[typeName] && {\n                keys: keyDirectivesMap[typeName],\n            }),\n        };\n        namedType.extensions = {\n            ...namedType.extensions,\n            federation: federationMetadata,\n        };\n        if (graphql_1.isObjectType(namedType)) {\n            for (const field of Object.values(namedType.getFields())) {\n                const [providesDirective] = utils_1.findDirectivesOnNode(field.astNode, 'provides');\n                if (providesDirective &&\n                    providesDirective.arguments &&\n                    utils_1.isStringValueNode(providesDirective.arguments[0].value)) {\n                    const fieldFederationMetadata = {\n                        ...utils_1.getFederationMetadata(field),\n                        serviceName,\n                        provides: utils_1.parseSelections(providesDirective.arguments[0].value.value),\n                        belongsToValueType: isValueType,\n                    };\n                    field.extensions = {\n                        ...field.extensions,\n                        federation: fieldFederationMetadata,\n                    };\n                }\n            }\n        }\n        for (const [fieldName, extendingServiceName] of Object.entries(extensionFieldsToOwningServiceMap)) {\n            if (graphql_1.isObjectType(namedType)) {\n                const field = namedType.getFields()[fieldName];\n                if (!field)\n                    continue;\n                const fieldFederationMetadata = {\n                    ...utils_1.getFederationMetadata(field),\n                    serviceName: extendingServiceName,\n                };\n                field.extensions = {\n                    ...field.extensions,\n                    federation: fieldFederationMetadata,\n                };\n                const [requiresDirective] = utils_1.findDirectivesOnNode(field.astNode, 'requires');\n                if (requiresDirective &&\n                    requiresDirective.arguments &&\n                    utils_1.isStringValueNode(requiresDirective.arguments[0].value)) {\n                    const fieldFederationMetadata = {\n                        ...utils_1.getFederationMetadata(field),\n                        requires: utils_1.parseSelections(requiresDirective.arguments[0].value.value),\n                    };\n                    field.extensions = {\n                        ...field.extensions,\n                        federation: fieldFederationMetadata,\n                    };\n                }\n            }\n        }\n    }\n    for (const field of externalFields) {\n        const namedType = schema.getType(field.parentTypeName);\n        if (!namedType)\n            continue;\n        const existingMetadata = utils_1.getFederationMetadata(namedType);\n        const typeFederationMetadata = {\n            ...existingMetadata,\n            externals: {\n                ...existingMetadata === null || existingMetadata === void 0 ? void 0 : existingMetadata.externals,\n                [field.serviceName]: [\n                    ...(((_a = existingMetadata === null || existingMetadata === void 0 ? void 0 : existingMetadata.externals) === null || _a === void 0 ? void 0 : _a[field.serviceName]) || []),\n                    field,\n                ],\n            },\n        };\n        namedType.extensions = {\n            ...namedType.extensions,\n            federation: typeFederationMetadata,\n        };\n    }\n    for (const directiveName of Object.keys(directiveDefinitionsMap)) {\n        const directive = schema.getDirective(directiveName);\n        if (!directive)\n            continue;\n        const directiveFederationMetadata = {\n            ...utils_1.getFederationMetadata(directive),\n            directiveDefinitions: directiveDefinitionsMap[directiveName],\n        };\n        directive.extensions = {\n            ...directive.extensions,\n            federation: directiveFederationMetadata,\n        };\n    }\n    for (const [typeName, fieldsToDirectivesMap] of typeNameToFieldDirectivesMap.entries()) {\n        const type = schema.getType(typeName);\n        if (!type)\n            continue;\n        for (const [fieldName, otherKnownDirectiveUsages,] of fieldsToDirectivesMap.entries()) {\n            const field = type.getFields()[fieldName];\n            const seenNonRepeatableDirectives = {};\n            const filteredDirectives = otherKnownDirectiveUsages.filter((directive) => {\n                const name = directive.name.value;\n                const matchingDirective = directives_1.default.find((d) => d.name === name);\n                if (matchingDirective === null || matchingDirective === void 0 ? void 0 : matchingDirective.isRepeatable)\n                    return true;\n                if (seenNonRepeatableDirectives[name])\n                    return false;\n                seenNonRepeatableDirectives[name] = true;\n                return true;\n            });\n            const existingMetadata = utils_1.getFederationMetadata(field);\n            const fieldFederationMetadata = {\n                ...existingMetadata,\n                otherKnownDirectiveUsages: filteredDirectives,\n            };\n            field.extensions = {\n                ...field.extensions,\n                federation: fieldFederationMetadata,\n            };\n        }\n    }\n}\nexports.addFederationMetadataToSchemaNodes = addFederationMetadataToSchemaNodes;\nfunction composeServices(services) {\n    const { typeToServiceMap, typeDefinitionsMap, typeExtensionsMap, directiveDefinitionsMap, externalFields, keyDirectivesMap, valueTypes, typeNameToFieldDirectivesMap, otherKnownDirectiveUsages, } = buildMapsFromServiceList(services);\n    let { schema, errors } = buildSchemaFromDefinitionsAndExtensions({\n        typeDefinitionsMap,\n        typeExtensionsMap,\n        directiveDefinitionsMap,\n        otherKnownDirectiveUsages,\n    });\n    schema = new graphql_1.GraphQLSchema({\n        ...schema.toConfig(),\n        ...utilities_1.mapValues(utils_1.defaultRootOperationNameLookup, typeName => typeName\n            ? schema.getType(typeName)\n            : undefined),\n        extensions: {\n            serviceList: services\n        }\n    });\n    schema = apollo_graphql_1.transformSchema(schema, type => {\n        if (graphql_1.isObjectType(type)) {\n            const config = type.toConfig();\n            return new graphql_1.GraphQLObjectType({\n                ...config,\n                interfaces: Array.from(new Set(config.interfaces)),\n            });\n        }\n        return undefined;\n    });\n    schema = graphql_1.lexicographicSortSchema(schema);\n    addFederationMetadataToSchemaNodes({\n        schema,\n        typeToServiceMap,\n        externalFields,\n        keyDirectivesMap,\n        valueTypes,\n        directiveDefinitionsMap,\n        typeNameToFieldDirectivesMap,\n    });\n    if (errors.length > 0) {\n        return { schema, errors };\n    }\n    else {\n        return {\n            schema,\n            supergraphSdl: printSupergraphSdl_1.printSupergraphSdl(schema, services),\n        };\n    }\n}\nexports.composeServices = composeServices;\n//# sourceMappingURL=compose.js.map"]},"metadata":{},"sourceType":"script"}