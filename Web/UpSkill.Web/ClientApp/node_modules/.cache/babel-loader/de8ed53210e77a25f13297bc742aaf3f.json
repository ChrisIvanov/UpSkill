{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.providesNotOnEntity = void 0;\n\nconst graphql_1 = require(\"graphql\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst providesNotOnEntity = ({\n  schema,\n  serviceList\n}) => {\n  var _a, _b;\n\n  const errors = [];\n  const types = schema.getTypeMap();\n\n  for (const [typeName, namedType] of Object.entries(types)) {\n    if (!graphql_1.isObjectType(namedType)) continue;\n\n    for (const [fieldName, field] of Object.entries(namedType.getFields())) {\n      const fieldFederationMetadata = utils_1.getFederationMetadata(field);\n      const serviceName = fieldFederationMetadata === null || fieldFederationMetadata === void 0 ? void 0 : fieldFederationMetadata.serviceName;\n      if (!serviceName && (fieldFederationMetadata === null || fieldFederationMetadata === void 0 ? void 0 : fieldFederationMetadata.provides) && !(fieldFederationMetadata === null || fieldFederationMetadata === void 0 ? void 0 : fieldFederationMetadata.belongsToValueType)) throw Error('Internal Consistency Error: field with provides information does not have service name.');\n      if (!serviceName) continue;\n\n      const getBaseType = type => graphql_1.isListType(type) || graphql_1.isNonNullType(type) ? getBaseType(type.ofType) : type;\n\n      const baseType = getBaseType(field.type);\n\n      if (fieldFederationMetadata === null || fieldFederationMetadata === void 0 ? void 0 : fieldFederationMetadata.provides) {\n        const typeNode = utils_1.findTypeNodeInServiceList(typeName, serviceName, serviceList);\n        const fieldNode = typeNode && 'fields' in typeNode ? (_a = typeNode.fields) === null || _a === void 0 ? void 0 : _a.find(field => field.name.value === fieldName) : undefined;\n        const providesDirectiveNode = utils_1.findDirectivesOnNode(fieldNode, 'provides');\n\n        if (!graphql_1.isObjectType(baseType)) {\n          errors.push(utils_1.errorWithCode('PROVIDES_NOT_ON_ENTITY', utils_1.logServiceAndType(serviceName, typeName, fieldName) + `uses the @provides directive but \\`${typeName}.${fieldName}\\` returns \\`${field.type}\\`, which is not an Object or List type. @provides can only be used on Object types with at least one @key, or Lists of such Objects.`, providesDirectiveNode));\n          continue;\n        }\n\n        const fieldType = types[baseType.name];\n        const selectedFieldIsEntity = (_b = utils_1.getFederationMetadata(fieldType)) === null || _b === void 0 ? void 0 : _b.keys;\n\n        if (!selectedFieldIsEntity) {\n          errors.push(utils_1.errorWithCode('PROVIDES_NOT_ON_ENTITY', utils_1.logServiceAndType(serviceName, typeName, fieldName) + `uses the @provides directive but \\`${typeName}.${fieldName}\\` does not return a type that has a @key. Try adding a @key to the \\`${baseType}\\` type.`, providesDirectiveNode));\n        }\n      }\n    }\n  }\n\n  return errors;\n};\n\nexports.providesNotOnEntity = providesNotOnEntity;","map":{"version":3,"sources":["../../../../src/composition/validate/postComposition/providesNotOnEntity.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.providesNotOnEntity = void 0;\nconst graphql_1 = require(\"graphql\");\nconst utils_1 = require(\"../../utils\");\nconst providesNotOnEntity = ({ schema, serviceList }) => {\n    var _a, _b;\n    const errors = [];\n    const types = schema.getTypeMap();\n    for (const [typeName, namedType] of Object.entries(types)) {\n        if (!graphql_1.isObjectType(namedType))\n            continue;\n        for (const [fieldName, field] of Object.entries(namedType.getFields())) {\n            const fieldFederationMetadata = utils_1.getFederationMetadata(field);\n            const serviceName = fieldFederationMetadata === null || fieldFederationMetadata === void 0 ? void 0 : fieldFederationMetadata.serviceName;\n            if (!serviceName &&\n                (fieldFederationMetadata === null || fieldFederationMetadata === void 0 ? void 0 : fieldFederationMetadata.provides) &&\n                !(fieldFederationMetadata === null || fieldFederationMetadata === void 0 ? void 0 : fieldFederationMetadata.belongsToValueType))\n                throw Error('Internal Consistency Error: field with provides information does not have service name.');\n            if (!serviceName)\n                continue;\n            const getBaseType = (type) => graphql_1.isListType(type) || graphql_1.isNonNullType(type)\n                ? getBaseType(type.ofType)\n                : type;\n            const baseType = getBaseType(field.type);\n            if (fieldFederationMetadata === null || fieldFederationMetadata === void 0 ? void 0 : fieldFederationMetadata.provides) {\n                const typeNode = utils_1.findTypeNodeInServiceList(typeName, serviceName, serviceList);\n                const fieldNode = typeNode && 'fields' in typeNode ?\n                    (_a = typeNode.fields) === null || _a === void 0 ? void 0 : _a.find(field => field.name.value === fieldName) : undefined;\n                const providesDirectiveNode = utils_1.findDirectivesOnNode(fieldNode, 'provides');\n                if (!graphql_1.isObjectType(baseType)) {\n                    errors.push(utils_1.errorWithCode('PROVIDES_NOT_ON_ENTITY', utils_1.logServiceAndType(serviceName, typeName, fieldName) +\n                        `uses the @provides directive but \\`${typeName}.${fieldName}\\` returns \\`${field.type}\\`, which is not an Object or List type. @provides can only be used on Object types with at least one @key, or Lists of such Objects.`, providesDirectiveNode));\n                    continue;\n                }\n                const fieldType = types[baseType.name];\n                const selectedFieldIsEntity = (_b = utils_1.getFederationMetadata(fieldType)) === null || _b === void 0 ? void 0 : _b.keys;\n                if (!selectedFieldIsEntity) {\n                    errors.push(utils_1.errorWithCode('PROVIDES_NOT_ON_ENTITY', utils_1.logServiceAndType(serviceName, typeName, fieldName) +\n                        `uses the @provides directive but \\`${typeName}.${fieldName}\\` does not return a type that has a @key. Try adding a @key to the \\`${baseType}\\` type.`, providesDirectiveNode));\n                }\n            }\n        }\n    }\n    return errors;\n};\nexports.providesNotOnEntity = providesNotOnEntity;\n//# sourceMappingURL=providesNotOnEntity.js.map"]},"metadata":{},"sourceType":"script"}