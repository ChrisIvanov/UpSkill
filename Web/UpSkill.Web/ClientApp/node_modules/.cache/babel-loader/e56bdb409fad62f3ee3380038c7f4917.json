{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst errors_1 = require(\"@oclif/errors\");\n\nconst errors_2 = require(\"./errors\");\n\nfunction validate(parse) {\n  function validateArgs() {\n    const maxArgs = parse.input.args.length;\n\n    if (parse.input.strict && parse.output.argv.length > maxArgs) {\n      const extras = parse.output.argv.slice(maxArgs);\n      throw new errors_2.UnexpectedArgsError({\n        parse,\n        args: extras\n      });\n    }\n\n    const missingRequiredArgs = [];\n    let hasOptional = false;\n    parse.input.args.forEach((arg, index) => {\n      if (!arg.required) {\n        hasOptional = true;\n      } else if (hasOptional) {\n        // (required arg) check whether an optional has occurred before\n        // optionals should follow required, not before\n        throw new errors_2.InvalidArgsSpecError({\n          parse,\n          args: parse.input.args\n        });\n      }\n\n      if (arg.required) {\n        if (!parse.output.argv[index] && parse.output.argv[index] !== 0) {\n          missingRequiredArgs.push(arg);\n        }\n      }\n    });\n\n    if (missingRequiredArgs.length > 0) {\n      throw new errors_2.RequiredArgsError({\n        parse,\n        args: missingRequiredArgs\n      });\n    }\n  }\n\n  function validateAcrossFlags(flag) {\n    const intersection = Object.entries(parse.input.flags).map(entry => entry[0]) // array of flag names\n    .filter(flagName => parse.output.flags[flagName] !== undefined) // with values\n    .filter(flagName => flag.exactlyOne && flag.exactlyOne.includes(flagName)); // and in the exactlyOne list\n\n    if (intersection.length === 0) {\n      // the command's exactlyOne may or may not include itself, so we'll use Set to add + de-dupe\n      throw new errors_1.CLIError(`Exactly one of the following must be provided: ${[...new Set(...(flag.exactlyOne || []), flag.name)].join(',')}`);\n    }\n  }\n\n  function validateFlags() {\n    for (const [name, flag] of Object.entries(parse.input.flags)) {\n      if (parse.output.flags[name] !== undefined) {\n        for (const also of flag.dependsOn || []) {\n          if (!parse.output.flags[also]) {\n            throw new errors_1.CLIError(`--${also}= must also be provided when using --${name}=`);\n          }\n        }\n\n        for (const also of flag.exclusive || []) {\n          // do not enforce exclusivity for flags that were defaulted\n          if (parse.output.metadata.flags[also] && parse.output.metadata.flags[also].setFromDefault) continue;\n          if (parse.output.metadata.flags[name] && parse.output.metadata.flags[name].setFromDefault) continue;\n\n          if (parse.output.flags[also]) {\n            throw new errors_1.CLIError(`--${also}= cannot also be provided when using --${name}=`);\n          }\n        }\n\n        for (const also of flag.exactlyOne || []) {\n          if (also !== name && parse.output.flags[also]) {\n            throw new errors_1.CLIError(`--${also}= cannot also be provided when using --${name}=`);\n          }\n        }\n      } else if (flag.required) {\n        throw new errors_2.RequiredFlagError({\n          parse,\n          flag\n        });\n      } else if (flag.exactlyOne && flag.exactlyOne.length > 0) {\n        validateAcrossFlags(flag);\n      }\n    }\n  }\n\n  validateArgs();\n  validateFlags();\n}\n\nexports.validate = validate;","map":{"version":3,"sources":["H:/Programming Repositories/Titans/Web/UpSkill.Web/ClientApp/node_modules/@oclif/parser/lib/validate.js"],"names":["Object","defineProperty","exports","value","errors_1","require","errors_2","validate","parse","validateArgs","maxArgs","input","args","length","strict","output","argv","extras","slice","UnexpectedArgsError","missingRequiredArgs","hasOptional","forEach","arg","index","required","InvalidArgsSpecError","push","RequiredArgsError","validateAcrossFlags","flag","intersection","entries","flags","map","entry","filter","flagName","undefined","exactlyOne","includes","CLIError","Set","name","join","validateFlags","also","dependsOn","exclusive","metadata","setFromDefault","RequiredFlagError"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst errors_1 = require(\"@oclif/errors\");\nconst errors_2 = require(\"./errors\");\nfunction validate(parse) {\n    function validateArgs() {\n        const maxArgs = parse.input.args.length;\n        if (parse.input.strict && parse.output.argv.length > maxArgs) {\n            const extras = parse.output.argv.slice(maxArgs);\n            throw new errors_2.UnexpectedArgsError({ parse, args: extras });\n        }\n        const missingRequiredArgs = [];\n        let hasOptional = false;\n        parse.input.args.forEach((arg, index) => {\n            if (!arg.required) {\n                hasOptional = true;\n            }\n            else if (hasOptional) {\n                // (required arg) check whether an optional has occurred before\n                // optionals should follow required, not before\n                throw new errors_2.InvalidArgsSpecError({ parse, args: parse.input.args });\n            }\n            if (arg.required) {\n                if (!parse.output.argv[index] && parse.output.argv[index] !== 0) {\n                    missingRequiredArgs.push(arg);\n                }\n            }\n        });\n        if (missingRequiredArgs.length > 0) {\n            throw new errors_2.RequiredArgsError({ parse, args: missingRequiredArgs });\n        }\n    }\n    function validateAcrossFlags(flag) {\n        const intersection = Object.entries(parse.input.flags)\n            .map(entry => entry[0]) // array of flag names\n            .filter(flagName => parse.output.flags[flagName] !== undefined) // with values\n            .filter(flagName => flag.exactlyOne && flag.exactlyOne.includes(flagName)); // and in the exactlyOne list\n        if (intersection.length === 0) {\n            // the command's exactlyOne may or may not include itself, so we'll use Set to add + de-dupe\n            throw new errors_1.CLIError(`Exactly one of the following must be provided: ${[\n                ...new Set(...flag.exactlyOne || [], flag.name),\n            ].join(',')}`);\n        }\n    }\n    function validateFlags() {\n        for (const [name, flag] of Object.entries(parse.input.flags)) {\n            if (parse.output.flags[name] !== undefined) {\n                for (const also of flag.dependsOn || []) {\n                    if (!parse.output.flags[also]) {\n                        throw new errors_1.CLIError(`--${also}= must also be provided when using --${name}=`);\n                    }\n                }\n                for (const also of flag.exclusive || []) {\n                    // do not enforce exclusivity for flags that were defaulted\n                    if (parse.output.metadata.flags[also] &&\n                        parse.output.metadata.flags[also].setFromDefault)\n                        continue;\n                    if (parse.output.metadata.flags[name] &&\n                        parse.output.metadata.flags[name].setFromDefault)\n                        continue;\n                    if (parse.output.flags[also]) {\n                        throw new errors_1.CLIError(`--${also}= cannot also be provided when using --${name}=`);\n                    }\n                }\n                for (const also of flag.exactlyOne || []) {\n                    if (also !== name && parse.output.flags[also]) {\n                        throw new errors_1.CLIError(`--${also}= cannot also be provided when using --${name}=`);\n                    }\n                }\n            }\n            else if (flag.required) {\n                throw new errors_2.RequiredFlagError({ parse, flag });\n            }\n            else if (flag.exactlyOne && flag.exactlyOne.length > 0) {\n                validateAcrossFlags(flag);\n            }\n        }\n    }\n    validateArgs();\n    validateFlags();\n}\nexports.validate = validate;\n"]},"metadata":{},"sourceType":"script"}